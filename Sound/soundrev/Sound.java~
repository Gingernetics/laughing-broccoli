import java.io.*;
import java.lang.Math.*;

public class Sound
{
    public static void main(String[] args)
    {
      try
	  {
	      int sensitivity = 5;

	      if ( args.length < 3 ) sensitivity = args[2];
	      // Open the wav file specified as the first argument
	      WavFile inFile = WavFile.openWavFile(new File(args[0]));

	      // Display information about the wav file
	      inFile.display();

	      // Get the number of audio channels in the wav file
	      int numChannels = inFile.getNumChannels();
	      long numFrames = inFile.getNumFrames();
	      long sampleRate = inFile.getSampleRate();
	      int validBits = inFile.getValidBits();
	      // Create a buffer to hold wav file in
	      double[] bufferin = new double[numFrames * numChannels];
	      // Read frames into buffer
	      inFile.readFrames(buffer, numFrames);
	      // Close the inFile
	      inFile.close();
	      double[][] bufferout = new double[numChannels][numFrames];
	      inToOut(bufferin, bufferout);
	      for (double[] channel : bufferout) channel += reverseByMeasure(channel) * 0.8;
	      WavFile outFile = WavFile.newWavFile(new File(args[1]), numChannels, numFrames, validBits, sampleRate);
	      outFile.writeFrames(bufferout, numFrames);
	  }
      catch (Exception e)
	  {
	      System.err.println(e);
	      System.out.println("Usage: Sound infile.wav outfile.wav [sensitivitylevel]");
		  }
    }
    public void inToOut(double[] in, double[][] out){
	for (int chan = 0; i < out.length; i++){
	    for (int i = 0; i < out[0].length; i ++) out[chan][i]=in[chan + i*(out.length)];
	}
    }
    public double[] reverseByMeasure(double[] orig){
	int[] beats = getBeats(orig);
	double[] ans = orig;
	for (int i = 0; i < beats.length - 1; i++) {
	    int start = beats[i];
		int end = beats[i+1];
		for (int j = 0; j < end - start; j++){
		    ans[start + j] = orig[end - j];
		}
	}
	return ans;
	    }

    // Returns an array of indexes, where each index represents a high-energy onset.
    public int[] getBeats(double[] orig){
	int[] peaks = getPeaks(orig);
	int index = 0;
	int[] ans;
	int prevmax;
	boolean isBeat;
	for (int i = sensitivity; i < peaks.length - sensitivity; i++){
	    prevmax = i;
	    for (int j = i - sensitivity; j < i; j++){
		if (abs(orig[peaks[j]]) > abs(orig[peaks[prevmax]])) prevmax = j;
	    }
	    isBeat = true;
	    for (int j = i; j < i + sensitivity; j++){
		if (abs(orig[peaks[j]]) > abs(orig[peaks[prevmax]])) isBeat = false;
	    }
	    if (isBeat) {
		ans[index] = peaks[i];
		i += sensitivity;
		index++;
	    }
	}
	return ans;
    }
    
    // Returns an array of indexes, where each index represents a location in orig with the max value of one waveform crest/trough
    public int[] getPeaks(double[] orig){
	int[] ans;
	index = 0;
	int[] zeroes = getZeroes(orig);
	int max;
	for (int i = 0; i < zeroes.length - 1; i++){
	    max = zeroes[i];
	    for (int j = zeroes[i]; j < zeroes[i+1]; j++){
		if (abs(orig[j]) > abs(orig[max])) max = j;
	    }
	    ans[index] = max;
	    index++;
	}
    }
    

    public int[] getZeroes(double[] orig){
	int[] ans;
	index = 0;
	for (int i = 1; i < orig.length; i++){
	    if (orig[i]/orig[i - 1] <= 0) {
		ans[index] = i;
		index++;
	    }
	}
	return ans;
    }
}
    